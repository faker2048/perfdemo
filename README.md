# 为什么做这个项目？

量化系统的两个性能主题：  
1. 高并发I/O - 数据处理，同时处理成千上万行情订阅、下单请求. 以及离线数据 pipeline 处理，大量历史数据。
2. 计算密集 - 海量历史数据回测、实时策略计算  


# perfdemo - 高性能并发与并行计算演示

一个展示 Python 并发和并行计算的完整项目。

- **Demo 1**: 使用python的asyncio编写的高并发 I/O 任务 demo，（Robust：支持重试机制，支持限流）。

- **Demo 2**: 简单的限流器（Token Bucket 算法），可以用于下单限流。

- **Demo 3**: 展示 python 自带的 ProcessPoolExecutor 来实现多进程并行运算，使用 asyncio 封装成 io 任务

- **Demo 4**: 利用 Numba JIT 并行加速，在 Python 代码中获得接近 C++ 的执行性能。

- **Demo 5**: 展示如何使用 PyBind11 + C++ 结合。


# 运行结果

在 linux 下的运行结果，cpu 7950X3D

```
=== Demo 1：高并发 I/O 测试 ===
完成 10000 条任务，耗时 0.338s  吞吐≈29628/s  p50=3.6ms  p95=12.1ms  p99=15.6ms

=== Demo 2：下单任务限流测试（200 QPS） ===
共 1000 单完成，用时 5.002s  实际QPS≈199.9 (目标≈200 QPS)

=== Demo 3：重计算任务 - Python 进程池并行 ===
进程池并行：32 个工作进程，总 4,000,000,000 次循环，用时 0.368s，吞吐≈10863.38 M it/s，校验和=2.083e+19

=== Demo 4：重计算任务 - Numba JIT 并行 ===
Numba 并行：32 线程，总 4,000,000,000 次循环，用时 0.021s，吞吐≈189366.98 M it/s，校验和=2.133e+22

=== Demo 5：重计算任务 - C++ OpenMP 并行 ===
C++ OpenMP：32 线程，总 4,000,000,000 次循环，用时 0.021s，吞吐≈194197.09 M it/s，校验和=2.133e+22
```

# 如何运行？

## 使用 uvx 

```
uvx git+https://github.com/faker2048/perfdemo
```
